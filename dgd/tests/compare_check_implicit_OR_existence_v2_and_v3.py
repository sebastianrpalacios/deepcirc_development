from __future__ import annotations
"""compare_or_functions.py

Compare ``check_implicit_OR_existence_v2`` against ``check_implicit_OR_existence_v3``
on a set of pickled NetworkX DAGs.

The loader now supports **three** storage formats seen in the project:

1. A plain ``networkx.DiGraph`` (pickled directly).
2. A *node‑link* dict generated by ``nx.node_link_data``.
3. The *custom list format* ``[num_nodes, edges, node_attrs]`` used by the
   un‑optimised NIG library (see `load_graph_pickle` in your training script).

CLI example
-----------
```bash
python compare_or_functions.py \
    --directory /path/to/graph_pickles \
    --num 250 \
    --inputs 2
```
"""

import argparse
import os
import pickle
import random
import pprint, textwrap
from typing import Any, Dict, List, Tuple

import networkx as nx  # noqa: F401 – type hints & ops

from dgd.utils.utils5 import (
    check_implicit_OR_existence_v2,
    check_implicit_OR_existence_v3,
)

# -----------------------------------------------------------------------------
# Loader helpers ---------------------------------------------------------------
# -----------------------------------------------------------------------------

def _from_custom_list(obj: Any) -> nx.DiGraph | None:
    """Rebuild a graph from the *[num_nodes, edges, node_attrs]* format.

    Returns the graph or ``None`` if *obj* is not in that format.
    """
    if not (isinstance(obj, (list, tuple)) and len(obj) == 3):
        return None

    num_nodes, edges, node_attrs = obj
    if not (
        isinstance(num_nodes, int)
        and isinstance(edges, list)
        and isinstance(node_attrs, dict)
    ):
        return None

    G = nx.DiGraph()
    # add nodes – if attrs missing, still add the node
    for v in range(num_nodes):
        attr = node_attrs.get(v)
        if attr is None:
            G.add_node(v)
        else:
            G.add_node(v, type=attr)

    # fallback: make sure all nodes appearing in edges exist
    for u, v in edges:
        if u not in G:
            G.add_node(u)
        if v not in G:
            G.add_node(v)
    G.add_edges_from(edges)
    return G


def _from_node_link_dict(obj: Any) -> nx.DiGraph | None:
    """Return graph if *obj* looks like a node‑link structure."""
    if isinstance(obj, dict) and {"nodes", "links"}.issubset(obj):
        try:
            return nx.node_link_graph(obj)
        except Exception:  # malformed → ignore
            return None
    return None


def _unwrap_graph(obj: Any, *, src: str) -> nx.DiGraph:
    """Extract or rebuild a ``networkx.DiGraph`` from *obj*.

    Checks:
    1. Direct DiGraph
    2. Node‑link dict
    3. Custom list format
    4. Recursive search inside containers (list/tuple/set/dict) up to depth 8
    """
    # 1) plain graph --------------------------------------------------------
    if isinstance(obj, nx.DiGraph):
        return obj

    # 2) node‑link dict -----------------------------------------------------
    g = _from_node_link_dict(obj)
    if g is not None:
        return g

    # 3) custom list format -------------------------------------------------
    g = _from_custom_list(obj)
    if g is not None:
        return g

    # 4) recursive descent --------------------------------------------------
    if isinstance(obj, (list, tuple, set)):
        for item in obj:
            try:
                return _unwrap_graph(item, src=src)  # depth+1 by call stack
            except TypeError:
                continue
    if isinstance(obj, dict):
        for item in obj.values():
            try:
                return _unwrap_graph(item, src=src)
            except TypeError:
                continue

    raise TypeError(
        f"Could not reconstruct a networkx.DiGraph from {src!r}; "
        f"top‑level object type: {type(obj).__name__}."
    )


# -----------------------------------------------------------------------------
# Bulk loader ------------------------------------------------------------------
# -----------------------------------------------------------------------------

def load_graphs(directory: str, n: int) -> List[Tuple[str, nx.DiGraph]]:
    """Load up to *n* graphs from *directory* (supports several formats)."""
    files = [
        os.path.join(directory, f) for f in os.listdir(directory) if f.lower().endswith(".pkl")
    ]
    if not files:
        raise FileNotFoundError(f"No *.pkl files found under '{directory}'.")

    random.shuffle(files)
    selected = files if n <= 0 or n > len(files) else files[:n]

    out: List[Tuple[str, nx.DiGraph]] = []
    for path in selected:
        with open(path, "rb") as fh:
            raw = pickle.load(fh)
        try:
            G = _unwrap_graph(raw, src=os.path.basename(path))
        except Exception as exc:
            raise RuntimeError(f"Failed to extract graph from '{path}': {exc}") from exc
        out.append((os.path.basename(path), G))
    return out


# -----------------------------------------------------------------------------
# Misc helpers -----------------------------------------------------------------
# -----------------------------------------------------------------------------

def find_output_node(G: nx.DiGraph):
    sinks = [v for v in G.nodes if G.out_degree(v) == 0]
    if not sinks:
        raise ValueError("Graph has no sinks (out‑degree 0)")
    sinks.sort()
    return sinks[0]


# -----------------------------------------------------------------------------
# Comparator -------------------------------------------------------------------
# -----------------------------------------------------------------------------

def compare_or_detectors(
    directory: str,
    n: int,
    size_input_to_or: int = 2,
    *,
    verbose: bool = True,
):
    """Run v2 vs v3 on up to *n* graphs in *directory*."""
    graphs = load_graphs(directory, n)
    mismatches: List[Tuple[str, Dict[str, Any], Dict[str, Any]]] = []

    # Pretty-printer configured once
    _pp = pprint.PrettyPrinter(indent=2, width=100, sort_dicts=False)

    for fname, G in graphs:
        output = find_output_node(G)

        v2_raw = check_implicit_OR_existence_v2(G, output, size_input_to_or)
        v3_raw = check_implicit_OR_existence_v3(G, output, size_input_to_or)

        # ---- order-insensitive comparison ----
        v2 = _normalize_result(v2_raw)
        v3 = _normalize_result(v3_raw)

        status = "✓ match" if v2 == v3 else "✗ mismatch"
        if verbose:
            print(f"{fname}: {status}")
            print("  v2:")
            print(textwrap.indent(_pp.pformat(v2), "    "))
            print("  v3:")
            print(textwrap.indent(_pp.pformat(v3), "    "))
            print()

        if v2 != v3:
            mismatches.append((fname, v2_raw, v3_raw))   # keep originals for inspection


    if verbose:
        tot, diff = len(graphs), len(mismatches)
        print(f"Summary: {diff}/{tot} mismatches.")
    return mismatches

def _normalize_result(obj: Any) -> Any:
    """Return *obj* with every `cut` and `cone` list sorted (recursively)."""
    if isinstance(obj, dict):
        out = {}
        for k, v in obj.items():
            if k in {"cut", "cone"} and isinstance(v, list):
                out[k] = sorted(v)                       # order-free comparison
            else:
                out[k] = _normalize_result(v)            # recurse
        return out
    # lists/tuples inside other keys stay untouched
    return obj

# -----------------------------------------------------------------------------
# CLI -------------------------------------------------------------------------
# -----------------------------------------------------------------------------

def _parse_args():
    p = argparse.ArgumentParser(description="Compare v2 vs v3 implicit‑OR detectors")
    p.add_argument("--directory", "-d", default=".")
    p.add_argument("--num", "-n", type=int, default=0)
    p.add_argument("--inputs", "-k", choices=[2, 3], type=int, default=2)
    return p.parse_args()


def main():
    a = _parse_args()
    compare_or_detectors(a.directory, a.num, size_input_to_or=a.inputs, verbose=True)


if __name__ == "__main__":
    main()
